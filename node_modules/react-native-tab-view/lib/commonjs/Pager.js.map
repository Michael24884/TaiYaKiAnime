{"version":3,"sources":["Pager.tsx"],"names":["Easing","EasingNode","OldEasing","Clock","Value","onChange","and","or","abs","add","block","call","ceil","clockRunning","cond","divide","eq","event","floor","greaterThan","lessThan","max","min","multiply","neq","not","round","set","spring","startClock","stopClock","sub","timing","Animated","PagerContext","React","createContext","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_VELOCITY_IMPACT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","SPRING_VELOCITY_SCALE","TIMING_CONFIG","duration","easing","out","cubic","Pager","Component","enabled","childPanGestureHandlerRefs","addGestureHandlerRef","ref","state","includes","setState","prevState","createRef","State","UNDETERMINED","props","navigationState","index","layout","width","routes","length","swipeVelocityImpact","undefined","springVelocityScale","layoutWidth","progress","springConfig","timingConfig","isSwipeGesture","setValue","nextIndex","key","keyboardDismissMode","onIndexChange","findIndex","route","jumpToIndex","Keyboard","dismiss","type","listener","enterListeners","push","indexOf","splice","value","Math","forEach","toValue","frameTime","position","time","finished","clock","I18nManager","isRTL","initialVelocityForSpring","velocityX","velocity","gestureX","nativeEvent","translationX","gestureState","gesturesEnabled","routesLength","toggleEnabled","currentIndexValue","pendingIndexValue","forceUpdate","lastEnteredIndex","handleEnteredIndexChange","isSwiping","indexAtSwipeEnd","currentIndex","onSwipeStart","onSwipeEnd","interactionHandle","InteractionManager","createInteractionHandle","input","TextInput","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","clearInteractionHandle","focusTextInput","ACTIVE","maybeCancel","offsetX","transitionTo","extrapolatedPosition","translateX","componentDidMount","context","gestureHandlerRef","componentDidUpdate","prevProps","componentWillUnmount","render","swipeEnabled","children","removeClippedSubviews","gestureHandlerProps","getTranslateX","addListener","removeListener","jumpTo","handleGestureEvent","styles","container","transform","providerVal","StyleSheet","create","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  StyleSheet,\n  TextInput,\n  Keyboard,\n  I18nManager,\n  InteractionManager,\n} from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, {\n  Easing as OldEasing,\n  // @ts-ignore\n  EasingNode,\n} from 'react-native-reanimated';\nimport memoize from './memoize';\n\nimport {\n  Layout,\n  NavigationState,\n  Route,\n  Listener,\n  PagerCommonProps,\n  EventEmitterProps,\n} from './types';\n\ntype Binary = 0 | 1;\n\nconst Easing = EasingNode || OldEasing;\n\nexport type Props<T extends Route> = PagerCommonProps & {\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  layout: Layout;\n  // Clip unfocused views to improve memory usage\n  // Don't enable this on iOS where this is buggy and views don't re-appear\n  removeClippedSubviews?: boolean;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.Node<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactNode;\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\n};\n\ntype ComponentState = {\n  enabled: boolean;\n  childPanGestureHandlerRefs: React.RefObject<PanGestureHandler>[];\n};\n\nconst {\n  Clock,\n  Value,\n  onChange,\n  and,\n  or,\n  abs,\n  add,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing,\n} = Animated;\n\nconst PagerContext = React.createContext({});\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\n\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\n\nconst SWIPE_DISTANCE_MINIMUM = 20;\n\nconst SWIPE_VELOCITY_IMPACT = 0.2;\n\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nconst SPRING_VELOCITY_SCALE = 1;\n\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic),\n};\n\nexport default class Pager<T extends Route> extends React.Component<\n  Props<T>,\n  ComponentState\n> {\n  static defaultProps = {\n    swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\n    springVelocityScale: SPRING_VELOCITY_SCALE,\n  };\n\n  state = {\n    enabled: true,\n    childPanGestureHandlerRefs: [] as React.RefObject<PanGestureHandler>[],\n  };\n\n  componentDidMount() {\n    // Register this PanGestureHandler with the parent (if parent exists)\n    // in order to coordinate gestures between handlers.\n    if (this.context && this.context.addGestureHandlerRef) {\n      this.context.addGestureHandlerRef(this.gestureHandlerRef);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const {\n      navigationState,\n      layout,\n      swipeVelocityImpact,\n      springVelocityScale,\n      springConfig,\n      timingConfig,\n    } = this.props;\n    const { index, routes } = navigationState;\n\n    if (\n      // Check for index in state to avoid unintended transition if component updates during swipe\n      (index !== prevProps.navigationState.index &&\n        index !== this.currentIndexValue) ||\n      // Check if the user updated the index correctly after an update\n      (typeof this.pendingIndexValue === 'number' &&\n        index !== this.pendingIndexValue)\n    ) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    }\n\n    // Reset the pending index\n    this.pendingIndexValue = undefined;\n\n    // Update our mappings of animated nodes when props change\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\n      this.swipeVelocityImpact.setValue(\n        swipeVelocityImpact !== undefined\n          ? swipeVelocityImpact\n          : SWIPE_VELOCITY_IMPACT\n      );\n    }\n\n    if (prevProps.springVelocityScale !== springVelocityScale) {\n      this.springVelocityScale.setValue(\n        springVelocityScale !== undefined\n          ? springVelocityScale\n          : SPRING_VELOCITY_SCALE\n      );\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(\n        springConfig.damping !== undefined\n          ? springConfig.damping\n          : SPRING_CONFIG.damping\n      );\n\n      this.springConfig.mass.setValue(\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\n      );\n\n      this.springConfig.stiffness.setValue(\n        springConfig.stiffness !== undefined\n          ? springConfig.stiffness\n          : SPRING_CONFIG.stiffness\n      );\n\n      this.springConfig.restSpeedThreshold.setValue(\n        springConfig.restSpeedThreshold !== undefined\n          ? springConfig.restSpeedThreshold\n          : SPRING_CONFIG.restSpeedThreshold\n      );\n\n      this.springConfig.restDisplacementThreshold.setValue(\n        springConfig.restDisplacementThreshold !== undefined\n          ? springConfig.restDisplacementThreshold\n          : SPRING_CONFIG.restDisplacementThreshold\n      );\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(\n        timingConfig.duration !== undefined\n          ? timingConfig.duration\n          : TIMING_CONFIG.duration\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  static contextType = PagerContext;\n\n  // Mechanism to add child PanGestureHandler refs in the case that this\n  // Pager is a parent to child Pagers. Allows for coordination between handlers\n  private providerVal = {\n    addGestureHandlerRef: (ref: React.RefObject<PanGestureHandler>) => {\n      if (!this.state.childPanGestureHandlerRefs.includes(ref)) {\n        this.setState((prevState: ComponentState) => ({\n          childPanGestureHandlerRefs: [\n            ...prevState.childPanGestureHandlerRefs,\n            ref,\n          ],\n        }));\n      }\n    },\n  };\n\n  // PanGestureHandler ref used for coordination with parent handlers\n  private gestureHandlerRef: React.RefObject<\n    PanGestureHandler\n  > = React.createRef();\n\n  // Clock used for tab transition animations\n  private clock = new Clock();\n\n  // Current state of the gesture\n  private velocityX = new Value(0);\n  private gestureX = new Value(0);\n  private gestureState = new Value(State.UNDETERMINED);\n  private offsetX = new Value(0);\n\n  // Tracks current state of gesture handler enabled\n  private gesturesEnabled = new Value(1);\n\n  // Current progress of the page (translateX value)\n  private progress = new Value(\n    // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\n  );\n\n  // Initial index of the tabs\n  private index = new Value(this.props.navigationState.index);\n\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\n\n  // Scene that was last entered\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\n\n  // Whether the user is currently dragging the screen\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\n\n  // Whether the update was due to swipe gesture\n  // This controls whether the transition will use a spring or timing animation\n  // Remember to set it before transition needs to occur\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\n\n  // Track the index value when a swipe gesture has ended\n  // This lets us know if a gesture end triggered a tab switch or not\n  private indexAtSwipeEnd: Animated.Value<number> = new Value(\n    this.props.navigationState.index\n  );\n\n  // Mappings to some prop values\n  // We use them in animation calculations, so we need live animated nodes\n  private routesLength = new Value(this.props.navigationState.routes.length);\n  private layoutWidth = new Value(this.props.layout.width);\n\n  // Determines how relevant is a velocity while calculating next position while swiping\n  private swipeVelocityImpact = new Value(\n    this.props.swipeVelocityImpact !== undefined\n      ? this.props.swipeVelocityImpact\n      : SWIPE_VELOCITY_IMPACT\n  );\n\n  private springVelocityScale = new Value(\n    this.props.springVelocityScale !== undefined\n      ? this.props.springVelocityScale\n      : SPRING_VELOCITY_SCALE\n  );\n\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\n  // It is calculated based on the translate value and layout width\n  // If we don't have the layout yet, we should return the current index\n  private position = cond(\n    this.layoutWidth,\n    divide(multiply(this.progress, -1), this.layoutWidth),\n    this.index\n  );\n\n  // Animation configuration\n  private springConfig = {\n    damping: new Value(\n      this.props.springConfig.damping !== undefined\n        ? this.props.springConfig.damping\n        : SPRING_CONFIG.damping\n    ),\n    mass: new Value(\n      this.props.springConfig.mass !== undefined\n        ? this.props.springConfig.mass\n        : SPRING_CONFIG.mass\n    ),\n    stiffness: new Value(\n      this.props.springConfig.stiffness !== undefined\n        ? this.props.springConfig.stiffness\n        : SPRING_CONFIG.stiffness\n    ),\n    restSpeedThreshold: new Value(\n      this.props.springConfig.restSpeedThreshold !== undefined\n        ? this.props.springConfig.restSpeedThreshold\n        : SPRING_CONFIG.restSpeedThreshold\n    ),\n    restDisplacementThreshold: new Value(\n      this.props.springConfig.restDisplacementThreshold !== undefined\n        ? this.props.springConfig.restDisplacementThreshold\n        : SPRING_CONFIG.restDisplacementThreshold\n    ),\n  };\n\n  private timingConfig = {\n    duration: new Value(\n      this.props.timingConfig.duration !== undefined\n        ? this.props.timingConfig.duration\n        : TIMING_CONFIG.duration\n    ),\n  };\n\n  // The reason for using this value instead of simply passing `this._velocity`\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\n  // Also, it's not possible to pass multiplied value there, because\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\n  // Animated.Value. So this value is being updated on each start of spring animation.\n  private initialVelocityForSpring = new Value(0);\n\n  // The current index change caused by the pager's animation\n  // The pager is used as a controlled component\n  // We need to keep track of the index to determine when to trigger animation\n  // The state will change at various points, we should only respond when we are out of sync\n  // This will ensure smoother animation and avoid weird glitches\n  private currentIndexValue = this.props.navigationState.index;\n\n  // The pending index value as result of state update caused by swipe gesture\n  // We need to set it when state changes from inside this component\n  // It also needs to be reset right after componentDidUpdate fires\n  private pendingIndexValue: number | undefined = undefined;\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n\n  // Listeners for the entered screen\n  private enterListeners: Listener[] = [];\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private jumpToIndex = (index: number) => {\n    // If the index changed, we need to trigger a tab switch\n    this.isSwipeGesture.setValue(FALSE);\n    this.nextIndex.setValue(index);\n  };\n\n  private jumpTo = (key: string) => {\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(\n      (route) => route.key === key\n    );\n\n    // A tab switch might occur when we're in the middle of a transition\n    // In that case, the index might be same as before\n    // So we conditionally make the pager to update the position\n    if (navigationState.index === index) {\n      this.jumpToIndex(index);\n    } else {\n      onIndexChange(index);\n\n      // When the index changes, the focused input will no longer be in current tab\n      // So we should dismiss the keyboard\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\n    const index = Math.max(\n      0,\n      Math.min(value, this.props.navigationState.routes.length - 1)\n    );\n\n    this.enterListeners.forEach((listener) => listener(index));\n  };\n\n  private transitionTo = (index: Animated.Node<number>) => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n\n    const state = {\n      position: this.progress,\n      time: new Value(0),\n      finished: new Value(FALSE),\n    };\n\n    return block([\n      cond(clockRunning(this.clock), NOOP, [\n        // Animation wasn't running before\n        // Set the initial values and start the clock\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\n        set(frameTime, 0),\n        set(state.time, 0),\n        set(state.finished, FALSE),\n        set(this.index, index),\n      ]),\n      cond(\n        this.isSwipeGesture,\n        // Animate the values with a spring for swipe\n        [\n          cond(\n            not(clockRunning(this.clock)),\n            I18nManager.isRTL\n              ? set(\n                  this.initialVelocityForSpring,\n                  multiply(-1, this.velocityX, this.springVelocityScale)\n                )\n              : set(\n                  this.initialVelocityForSpring,\n                  multiply(this.velocityX, this.springVelocityScale)\n                )\n          ),\n          spring(\n            this.clock,\n            { ...state, velocity: this.initialVelocityForSpring },\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\n          ),\n        ],\n        // Otherwise use a timing animation for faster switching\n        timing(\n          this.clock,\n          { ...state, frameTime },\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\n        )\n      ),\n      cond(not(clockRunning(this.clock)), startClock(this.clock)),\n      cond(state.finished, [\n        // Reset values\n        set(this.isSwipeGesture, FALSE),\n        set(this.gestureX, 0),\n        set(this.velocityX, 0),\n        // When the animation finishes, stop the clock\n        stopClock(this.clock),\n      ]),\n    ]);\n  };\n\n  private handleGestureEvent = event([\n    {\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private extrapolatedPosition = add(\n    this.gestureX,\n    multiply(this.velocityX, this.swipeVelocityImpact)\n  );\n\n  private toggleEnabled = () => {\n    if (this.state.enabled)\n      this.setState({ enabled: false }, () => {\n        this.setState({ enabled: true });\n      });\n  };\n\n  // Cancel gesture if swiping back from the initial tab or forward from the last tab.\n  // Enables parent Pager to pick up the gesture if one exists.\n  private maybeCancel = block([\n    cond(\n      and(\n        this.gesturesEnabled,\n        or(\n          and(\n            eq(this.index, sub(this.routesLength, 1)),\n            lessThan(this.gestureX, 0)\n          ),\n          and(eq(this.index, 0), greaterThan(this.gestureX, 0))\n        )\n      ),\n      set(this.gesturesEnabled, 0)\n    ),\n  ]);\n\n  private translateX = block([\n    onChange(\n      this.gesturesEnabled,\n      cond(\n        not(this.gesturesEnabled),\n        call([this.gesturesEnabled], this.toggleEnabled)\n      )\n    ),\n    onChange(\n      this.index,\n      call([this.index], ([value]) => {\n        this.currentIndexValue = value;\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n        if (value !== this.props.navigationState.index) {\n          // If the index changed, and previous animation has finished, update state\n          this.props.onIndexChange(value);\n\n          this.pendingIndexValue = value;\n\n          // Force componentDidUpdate to fire, whether user does a setState or not\n          // This allows us to detect when the user drops the update and revert back\n          // It's necessary to make sure that the state stays in sync\n          this.forceUpdate();\n        }\n      })\n    ),\n    onChange(\n      this.position,\n      // Listen to updates in the position to detect when we enter a screen\n      // This is useful for things such as lazy loading when index change will fire too late\n      cond(\n        I18nManager.isRTL\n          ? lessThan(this.gestureX, 0)\n          : greaterThan(this.gestureX, 0),\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, floor(this.position)),\n          call([floor(this.position)], this.handleEnteredIndexChange),\n        ]),\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, ceil(this.position)),\n          call([ceil(this.position)], this.handleEnteredIndexChange),\n        ])\n      )\n    ),\n    onChange(\n      this.isSwiping,\n      // Listen to updates for this value only when it changes\n      // Without `onChange`, this will fire even if the value didn't change\n      // We don't want to call the listeners if the value didn't change\n      [\n        cond(not(this.isSwiping), set(this.gesturesEnabled, 1)),\n        call(\n          [this.isSwiping, this.indexAtSwipeEnd, this.index],\n          ([isSwiping, indexAtSwipeEnd, currentIndex]: readonly number[]) => {\n            const {\n              keyboardDismissMode,\n              onSwipeStart,\n              onSwipeEnd,\n            } = this.props;\n\n            if (isSwiping === TRUE) {\n              onSwipeStart?.();\n              this.interactionHandle = InteractionManager.createInteractionHandle();\n\n              if (keyboardDismissMode === 'auto') {\n                // @ts-ignore: the method is only available in newer React Native, but types aren't up-to-date\n                const input = TextInput.State.currentlyFocusedInput\n                  ? // @ts-ignore\n                    TextInput.State.currentlyFocusedInput()\n                  : TextInput.State.currentlyFocusedField();\n\n                // When a gesture begins, blur the currently focused input\n                TextInput.State.blurTextInput(input);\n\n                // Store the id of this input so we can refocus it if gesture was cancelled\n                this.previouslyFocusedTextInput = input;\n              } else if (keyboardDismissMode === 'on-drag') {\n                Keyboard.dismiss();\n              }\n            } else {\n              onSwipeEnd?.();\n\n              if (this.interactionHandle !== null) {\n                InteractionManager.clearInteractionHandle(\n                  this.interactionHandle\n                );\n              }\n\n              if (keyboardDismissMode === 'auto') {\n                if (indexAtSwipeEnd === currentIndex) {\n                  // The index didn't change, we should restore the focus of text input\n                  const input = this.previouslyFocusedTextInput;\n\n                  if (input) {\n                    TextInput.State.focusTextInput(input);\n                  }\n                }\n\n                this.previouslyFocusedTextInput = null;\n              }\n            }\n          }\n        ),\n      ]\n    ),\n    onChange(\n      this.nextIndex,\n      cond(neq(this.nextIndex, UNSET), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), stopClock(this.clock)),\n        set(this.gestureX, 0),\n        // Update the index to trigger the transition\n        set(this.index, this.nextIndex),\n        set(this.nextIndex, UNSET),\n      ])\n    ),\n    cond(\n      eq(this.gestureState, State.ACTIVE),\n      [\n        this.maybeCancel,\n        cond(this.isSwiping, NOOP, [\n          // We weren't dragging before, set it to true\n          set(this.isSwiping, TRUE),\n          set(this.isSwipeGesture, TRUE),\n          // Also update the drag offset to the last progress\n          set(this.offsetX, this.progress),\n        ]),\n        // Update progress with previous offset + gesture distance\n        set(\n          this.progress,\n          I18nManager.isRTL\n            ? sub(this.offsetX, this.gestureX)\n            : add(this.offsetX, this.gestureX)\n        ),\n        // Stop animations while we're dragging\n        stopClock(this.clock),\n      ],\n      [\n        set(this.isSwiping, FALSE),\n        set(this.indexAtSwipeEnd, this.index),\n        this.transitionTo(\n          cond(\n            and(\n              // We should consider velocity and gesture distance only when a swipe ends\n              // The gestureX value will be non-zero when swipe has happened\n              // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\n              // For other factors such as state update, the velocity and gesture distance don't matter\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\n              greaterThan(\n                abs(this.extrapolatedPosition),\n                divide(this.layoutWidth, 2)\n              )\n            ),\n            // For swipe gesture, to calculate the index, determine direction and add to index\n            // When the user swipes towards the left, we transition to the next tab\n            // When the user swipes towards the right, we transition to the previous tab\n            round(\n              min(\n                max(\n                  0,\n                  sub(\n                    this.index,\n                    cond(\n                      greaterThan(this.extrapolatedPosition, 0),\n                      I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                      I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                    )\n                  )\n                ),\n                sub(this.routesLength, 1)\n              )\n            ),\n            // Index didn't change/changed due to state update\n            this.index\n          )\n        ),\n      ]\n    ),\n    this.progress,\n  ]);\n\n  private getTranslateX = memoize(\n    (\n      layoutWidth: Animated.Node<number>,\n      routesLength: Animated.Node<number>,\n      translateX: Animated.Node<number>\n    ) =>\n      multiply(\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n        min(\n          max(\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\n            translateX\n          ),\n          0\n        ),\n        I18nManager.isRTL ? -1 : 1\n      )\n  );\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps,\n    } = this.props;\n\n    const translateX = this.getTranslateX(\n      this.layoutWidth,\n      this.routesLength,\n      this.translateX\n    );\n\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: (children) => (\n        <PanGestureHandler\n          ref={this.gestureHandlerRef}\n          simultaneousHandlers={this.state.childPanGestureHandlerRefs}\n          waitFor={this.state.childPanGestureHandlerRefs}\n          enabled={layout.width !== 0 && swipeEnabled && this.state.enabled}\n          onGestureEvent={this.handleGestureEvent}\n          onHandlerStateChange={this.handleGestureEvent}\n          activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          {...gestureHandlerProps}\n        >\n          <Animated.View\n            removeClippedSubviews={removeClippedSubviews}\n            style={[\n              styles.container,\n              layout.width\n                ? {\n                    width: layout.width * navigationState.routes.length,\n                    transform: [{ translateX }] as any,\n                  }\n                : null,\n            ]}\n          >\n            <PagerContext.Provider value={this.providerVal}>\n              {children}\n            </PagerContext.Provider>\n          </Animated.View>\n        </PanGestureHandler>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n"]}